// Generated by CoffeeScript 1.3.3
var DeferredProbeShadowMap, Illumination, Quad, Rendernode, SHConstants, Sphere, Texture2D,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Quad = require('/webgl/quad');

Sphere = require('/webgl/sphere');

Texture2D = require('/webgl/texture').Texture2D;

Rendernode = require('/rendernode');

DeferredProbeShadowMap = require('/depth').DeferredProbeShadowMap;

SHConstants = (function(_super) {

  __extends(SHConstants, _super);

  function SHConstants(gui) {
    this.change = __bind(this.change, this);

    var folder;
    SHConstants.__super__.constructor.call(this);
    gui.remember(this);
    this.c1 = 0.43;
    this.c2 = 0.66;
    this.band3 = 1.0;
    this.c3 = 0.9;
    this.c4 = 0.34;
    this.c5 = 0.43;
    this.data = new Float32Array(5);
    folder = gui.addFolder('Harmonics');
    folder.add(this, 'c1', 0.0, 4.0).name('L0').onChange(this.change);
    folder.add(this, 'c2', 0.0, 4.0).name('L1').onChange(this.change);
    folder.add(this, 'band3', 0.0, 4.0).name('L2').onChange(this.change);
    folder.add(this, 'c3', 0.0, 4.0).name('L2m2/L2m1/L21').onChange(this.change);
    folder.add(this, 'c4', 0.0, 4.0).name('L20').onChange(this.change);
    folder.add(this, 'c5', 0.0, 4.0).name('L22').onChange(this.change);
    this.updateData();
  }

  SHConstants.prototype.updateData = function() {
    this.data[0] = this.c1;
    this.data[1] = this.c2;
    this.data[2] = this.band3 * this.c3;
    this.data[3] = this.band3 * this.c4;
    return this.data[4] = this.band3 * this.c5;
  };

  SHConstants.prototype.change = function() {
    this.updateData();
    return this.trigger('change');
  };

  return SHConstants;

})(require('/events'));

return Illumination = (function() {

  function Illumination(gl, gui, sun, sundepth, lighting, model, normaldepth) {
    this.gl = gl;
    this.lighting = lighting;
    this.update = __bind(this.update, this);

    this.shconst = new SHConstants(gui).on('change', this.update);
    this.proj = new Mat4().perspective(90, 1, 0.01, 42);
    this.view = new Mat4();
    this.mapsize = 32;
    this.probesize = 16;
    this.generateProbes();
    this.renderProbes(model);
    this.debug = new Rendernode(this.gl, {
      program: get('debug.shader'),
      drawable: new Sphere(this.gl, 0.6),
      depthBuffer: true,
      depthTest: true,
      depthWrite: true,
      cullFace: 'BACK',
      type: floatExt.type
    });
    this.coefficients = new Rendernode(this.gl, {
      width: 9,
      height: this.probes.length,
      program: get('harmonics.shader'),
      drawable: quad,
      filter: 'nearest',
      type: floatExt.type
    });
    this.probes_shadow = new DeferredProbeShadowMap(this.gl, {
      drawable: model,
      depth: sundepth,
      probes_normal: this.probes_normal,
      probes_position: this.probes_position,
      light: sun,
      blurred: true
    });
    this.probes_shadow.resize(this.probesize * 6, this.probesize * this.probes.length).updateShadow();
    this.probes_global_illumination = new Rendernode(gl, {
      width: this.probesize * 6,
      height: this.probesize * this.probes.length,
      program: get('probes_global_illumination.shader'),
      blend: 'additive',
      type: floatExt.type,
      drawable: quad
    });
    this.lightprobes = new Rendernode(this.gl, {
      width: this.probesize * 6,
      height: this.probesize * this.probes.length,
      program: get('composit.shader'),
      drawable: quad,
      filter: 'nearest',
      type: floatExt.type
    });
    this.update();
  }

  Illumination.prototype.generateProbes = function() {
    var i, _i, _j, _results;
    this.probes = [];
    for (i = _i = 0; _i < 7; i = ++_i) {
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 2.2,
        z: 0
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 2.2,
        z: 5.5
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 2.2,
        z: -5.5
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 7.0,
        z: 0
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 7.0,
        z: 5.5
      });
      this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 7.0,
        z: -5.5
      });
    }
    _results = [];
    for (i = _j = 1; _j < 6; i = ++_j) {
      _results.push(this.probes.push({
        x: i * 4.5 - 3 * 4.5,
        y: 12.5,
        z: 0
      }));
    }
    return _results;
  };

  Illumination.prototype.renderProbes = function(model) {
    var i, probe, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (get.exists('diffusemap.jpg')) {
      this.diffusemap = new Texture2D(this.gl).bind().upload(get('diffusemap.jpg')).nearest().clampToEdge().unbind();
    } else {
      this.diffusemap = new Rendernode(this.gl, {
        width: this.mapsize * 6,
        height: this.mapsize * this.probes.length,
        program: get('cube_diffuse.shader'),
        drawable: highresmodel,
        depthTest: true,
        depthWrite: true,
        cullFace: 'BACK',
        filter: 'nearest',
        depthBuffer: true
      });
      this.diffusemap.start().clear(0, 0, 0);
      this.diffusemap.mat4('proj', this.proj);
      _ref = this.probes;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        probe = _ref[i];
        this.renderProbe(i, this.diffusemap, 'diffuse_texture', probe.x, probe.y, probe.z, this.mapsize);
      }
      this.diffusemap.end();
      this.diffusemap = this.diffusemap.output;
    }
    this.probes_position = new Rendernode(this.gl, {
      width: this.probesize * 6,
      height: this.probesize * this.probes.length,
      program: get('probes_position.shader'),
      drawable: model,
      depthTest: true,
      depthWrite: true,
      cullFace: 'BACK',
      filter: 'nearest',
      type: floatExt.type,
      depthBuffer: true
    });
    this.probes_position.start().clear(0, 0, 0);
    this.probes_position.mat4('proj', this.proj);
    _ref1 = this.probes;
    for (i = _j = 0, _len1 = _ref1.length; _j < _len1; i = ++_j) {
      probe = _ref1[i];
      this.renderProbe(i, this.probes_position, null, probe.x, probe.y, probe.z, this.probesize);
    }
    this.probes_position.end();
    this.probes_position = this.probes_position.output;
    this.probes_normal = new Rendernode(this.gl, {
      width: this.probesize * 6,
      height: this.probesize * this.probes.length,
      program: get('probes_normal.shader'),
      drawable: model,
      depthTest: true,
      depthWrite: true,
      cullFace: 'BACK',
      filter: 'nearest',
      type: floatExt.type,
      depthBuffer: true
    });
    this.probes_normal.start().clear(0, 0, 0, 0);
    this.probes_normal.mat4('proj', this.proj);
    _ref2 = this.probes;
    for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
      probe = _ref2[i];
      this.renderProbe(i, this.probes_normal, null, probe.x, probe.y, probe.z, this.probesize);
    }
    this.probes_normal.end();
    return this.probes_normal = this.probes_normal.output;
  };

  Illumination.prototype.renderProbe = function(i, node, texture_type, x, y, z, s) {
    var offset;
    offset = i * s;
    this.view.identity().translateVal3(-x, -y, -z);
    node.viewport(s * 0, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatey(180).translateVal3(-x, -y, -z);
    node.viewport(s * 1, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatey(-90).translateVal3(-x, -y, -z);
    node.viewport(s * 2, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatey(90).translateVal3(-x, -y, -z);
    node.viewport(s * 3, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatex(-90).translateVal3(-x, -y, -z);
    node.viewport(s * 4, offset, s, s).mat4('view', this.view).drawModel(texture_type);
    this.view.identity().rotatex(90).translateVal3(-x, -y, -z);
    return node.viewport(s * 5, offset, s, s).mat4('view', this.view).drawModel(texture_type);
  };

  Illumination.prototype.updateGlobalIllumination = function() {
    var i, probe, _i, _len, _ref;
    this.probes_global_illumination.start().clear(0, 0, 0, 0).f('gi_gain', this.lighting.giGain).sampler('coefficients', this.coefficients).val2('coefficients_size', this.coefficients.width, this.coefficients.height).sampler('probes_position', this.probes_position).sampler('probes_normal', this.probes_normal);
    _ref = this.probes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      probe = _ref[i];
      this.probes_global_illumination.val4('lightprobe', probe.x, probe.y, probe.z, i).draw();
    }
    return this.probes_global_illumination.end();
  };

  Illumination.prototype.updateLightprobes = function() {
    return this.lightprobes.start().sampler('direct', this.probes_shadow).sampler('global', this.probes_global_illumination).sampler('albedo', this.diffusemap).sampler('probes_normal', this.probes_normal).vec3('sun_radiance', this.lighting.sun_radiance).vec3('sky_radiance', this.lighting.sky_radiance).draw().end();
  };

  Illumination.prototype.updateDirectLight = function() {
    return this.probes_shadow.updateShadow();
  };

  Illumination.prototype.updateCoefficients = function() {
    return this.coefficients.start().val2('lightprobes_size', this.lightprobes.width, this.lightprobes.height).sampler('lightprobes', this.lightprobes).fv('shconst', this.shconst.data).draw().end();
  };

  Illumination.prototype.update = function() {
    var i, _i, _ref, _results;
    this.probes_global_illumination.start().clear().end();
    this.updateLightprobes();
    this.updateCoefficients();
    _results = [];
    for (i = _i = 0, _ref = this.lighting.bounces - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      this.updateGlobalIllumination();
      this.updateLightprobes();
      _results.push(this.updateCoefficients());
    }
    return _results;
  };

  Illumination.prototype.drawDebug = function(camera, normaldepth) {
    var i, probe, _i, _len, _ref;
    this.debug.start().clearBoth(0, 0, 0, 0).f('gi_gain', this.lighting.giGain).sampler('normaldepth', normaldepth).sampler('coefficients', this.coefficients).val2('coefficients_size', this.coefficients.width, this.coefficients.height).mat4('proj', camera.proj).mat4('view', camera.view);
    _ref = this.probes;
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      probe = _ref[i];
      this.debug.val3('offset', probe.x, probe.y, probe.z).f('index', i).draw();
    }
    return this.debug.end();
  };

  return Illumination;

})();
